package 算法.动态规划.背包;
//https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/0-1-bei-bao-wen-ti-xiang-jie-zhen-dui-ben-ti-de-yo/
//看到题目，首先想一想题目为什么要告诉你是正整数，有 0 的话行不行，是实数行不行，是负数行不行。
//
//回答：实际上做以上限制了是降低了难度的。
//
//有 0 当然可以啦，不过 0 的存在意义不大，放在哪个子集都是可以的；
//再说实数，实数有可能是无理数，也可能是无限不循环小数，因为我们要计算整个数组元素的和的一半，在做除法，然后在比较两个子集元素的和是否相等的时候，就会遇到精度的问题；
//再说负数，负数其实也是可以存在的，但是你可能要用搜索（回溯）的办法去完成这道题了。
//再看看题目给出的“注意”：
//
//每个数组中的元素不会超过 100
//数组的大小不会超过 200
//简单计算一下：数组元素的和最大是 100 \times 200 = 20000100×200=20000，不是很大，现代计算机可以轻松完成这个级别的运算。我想分析到这里，不难看出，题目给的这些条件和“注意”就是在暗示你使用“动态规划”了。
//
//方法一：动态规划
//这是一道以 0-1 背包问题为背景的算法练习题，我们把这个题目翻译一下：
//
//给定一个只包含正整数的非空数组。是否可以从这个数组中挑选出一些正整数，每个数只能用一次，使得这些数的和等于整个数组元素的和的一半。
//
//0-1 背包问题也是最基础的背包问题，它的特点是：待挑选的物品有且仅有一个，可以选择也可以不选择。下面我们定义状态，不妨就用问题的问法定义状态试试看。
//
//dp[i][j] ：表示从数组的 [0, i] 这个子区间内挑选一些正整数，每个数只能用一次，使得这些数的和等于 j。
//
//根据我们学习的 0-1 背包问题的状态转移推导过程，新来一个数，例如是 nums[i]，根据这个数可能选择也可能不被选择：
//
//如果不选择 nums[i]，在 [0, i - 1] 这个子区间内已经有一部分元素，使得它们的和为 j ，那么 dp[i][j] = true；
//如果选择 nums[i]，在 [0, i - 1] 这个子区间内就得找到一部分元素，使得它们的和为 j - nums[i] ，我既然这样写出来了，你就应该知道，这里讨论的前提条件是 nums[i] <= j。
//以上二者成立一条都行。于是得到状态转移方程是：
//
//dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i]], (nums[i] <= j)
public class 分割等和子集416 {
    public boolean canPartition(int[] nums) {
        if (nums == null || nums.length == 0 || nums.length == 1) {
            return false;
        }
        int sum = 0;
        for (int a : nums) {
            sum += a;
        }
        if ((sum & 1) != 0) {
            return false;  //和为奇则不可能存在.
        }
        int W = sum >> 1;
        boolean[] dp = new boolean[W + 1];
        dp[0] = true;  //取和为0就是不取即可,所以都为true
        for (int a : nums) {
            for (int i = W; i >= a; i--) {
                dp[i] = dp[i] || dp[i - a];
            }
        }
        return dp[W];
    }
}
