package 算法.动态规划.分割整数;
// 2 = 1+1 3 = 1+2 4=2+2 5=2+3 6=3+3
//思路1:动归.这种题目,一般先自己找规律,写一写简单的,不要直接去找规律,把情况分清楚,动归就是非常简略的无脑进行枚举,
public class 整数拆分343 {
//    public int integerBreak(int n) {
//        int[] dp = new int[n + 1];  //作为从小到大,每个分割后最大的乘积值
//        dp[0] = 0;
//        dp[1] = 1;//前两个是不满足条件的填充进数组
//        // dp[2] = 1;  //注意别写成2,也可以不写,只是作为第一个有效值.
//        for (int i = 2; i <= n; i++) { //填充后面的dp数组.
//            for (int j = 1; j < i; j++) {  //j是从1开始切分整数,进行乘积比较,主要比较j*dp[i-j],和j*(i-j);看看哪个大,当然还有dp[i],开始默认为0,后面会在j值变大时,dp[i]作为上一j的最大乘积值,逐渐更新.
//                dp[i] = Math.max(dp[i], Math.max(j * dp[i - j], j * (i - j)));  //右侧dp[i]为上一j循环的最大乘积值.
//            }
//        }
//        return dp[n];
//    }


    //思路2.我们到底应该将这个数字分为多少份呢？
    //答案是将任意数组字分为3m+2n时结果最大。
    //
    //这是因为，首先，如果对2，3进行拆分，2只有一种拆分方法就是1+1；3有两种拆分方法 1+2；1+1+1；
    //
    //对于这两个数字，无论如何拆分得到的拆分单元的乘积均小于原始值；
    //
    //而对于任意n>3, 拆分为两个数得到的乘积(n/2)^2 (n为偶数时)或 (n/2)((n+1)/2)*(n/2)（n为奇数时）均大于n;
    //
    //因为对于函数y=(n/2)^2-n 或 (n/2)((n+1)/2)*(n/2)-n在n>3时均有y>0（且求导可发现在n>=3时单调递增）;
    //
    //也就是说，当n>3时，对n进行拆分得到的数字的乘积一定大于原始值；
    //
    //也就是说，2和3是该问题的最小不可分单元；
    //###答案是尽可能多的3，剩余的值拆分为2；
    class Solution {
        public int integerBreak(int n) {
            if(n == 2 || n == 3){
                return n-1;
            }
            int res = 1;
            while(n > 4){
                res *= 3;
                n -= 3;   //##注意是-3.
            }
            return res*n;  //若是为4的时候直接到return 1*4.
        }
    }
}
