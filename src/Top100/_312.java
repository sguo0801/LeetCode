package Top100;

public class _312 {
    //看到这个题目，很显然，第一反应不是用动态规划解决，而是回溯：
    //假设现在有n个气球，所以按照题意，若每踩一个气球定义为一个step，则需要n个step才能完成游戏。
    // 当进行到第i个step的时候(i<n)，还剩下(n-i)个气球，也就是还需要(n-i)step才能完成游戏。
    // 用枚举，第一次踩气球，有n种踩法，第2次踩气球有(n-1)中踩法，所以整个游戏有(n!)种完成途径，每个完成途径都可以计算出相应的获得的coin，然后比较一下，取出最大的即可。
    // 但是这个算法的复杂度为O(n!)，无法接受。所以下面我们逐步优化。
    //通过观察可以知道。定义：现存的气球集合N，被踩的气球集合M。则 maxcoin(N)和 M 是无关的。
    // 也就是已经被踩的气球不会影响到现存的气球的maxcoin计算(这里其实可以看到此问题符合动态规划里面的无后效性。
    // 既然先被踩的气球不会影响后被踩的气球的maxcoin，那我们可以选择先找出被踩两个气球时的maxcoin，被踩三个气球时的maxcoin，......，被踩n个气球时的maxcoin，
    // 显然这是一个重叠子问题，并且以上描述显然是一个DP的bottom up思路。但是，计算被踩k个气球时的maxcoin，需要枚举C(n,k)种情况，并进行比较，这导致子问题过多，
    // 也是就是每个递归节点有过多的子节点，增加了计算复杂度，虽然比原始的O(n!)要好一点，但并不优于O(2^n)，我们需要寻找具有二项式时间的算法。
    //
    //更好的想法：
    //根据前面的分析，该问题可以分解为多个子问题，并逐一解决。于是，我们可以尝试是否可以用分治方法来解决呢？
    //
    //这里需要明确可以用分治方法解决的问题以及可以用DP解决的问题的异同：
    //
    //分治和DP都需要将原问题分解成小问题，然后逐一解决；不过分治方法的每个小问题都是不相关的，而DP的子问题则是重叠的(overlapping)。
    //但是通过前面的分析也知道，之前描述的子问题都是重叠的 (比如你在计算踩K个气球时的maxcoin，肯定会涉及到踩K-1个气球时的结果，这也是可以用bottom up 的意义)，
    //因此根本不能用分治方法来求解。自然的一个想法是，我们可不可以先把整体分割，再分别在被分割的各个子整体中用bottom up。这显然是可行的。不过问题在于怎么分割整体，
    // 因为整体的分割需要保证各个整体在后面的计算中要保持相互独立性。比如对于[a1,a2,a3,a4,a5,a6,......,an]，将分割成两个子整体，分割点为k，
    // 则得到 N1 = [a1,a2,a3,....,a(k-1)], N2 = [a(k+1),a(k+2),.....,an]。这里分割点k的意义是踩破了第k个气球。于是把整体分成了两部分，
    // 问题在于，根据计算规则，k气球破了之后，a(k-1)和a(k+1)会变成相邻的，如果此时踩a(k-1)或者a(k+1)，则都会收到另一个子整体的影响，这样的话，两个子问题就不独立，也就不能用分治了。
    // 所以关键的问题在于确定k。
    //可以发现：N1和N2相互独立    <=>  k点为对于整体N的游戏时，最后一个被踩破的气球。
    //也就是k点被踩破之前，N1和N2重点的气球都不会相互影响。于是我们就成功构造了子问题。因此分治加dp就可以对问题进行求解了。
    //写一下状态传递方程：
    //
    //dp[left][right] = max{dp[left][right] , nums[left] * nums[i] * nums[right]  +  nums[left] * nums[i]  +  nums[i] * nums[right]};
    //
    //其中 left<i<right , dp[left][right]即为当前子问题：第left和第right之间位置的气球的maxcoin。

    //比如i是最后戳破的,那么就是在i被戳破之前,应该是有0, n+1,还有i这三个索引没有被戳破,也就是之前的max为nums[0] * nums[i]  +  nums[i] * nums[n+1].这里是加入了-1和n这两个索引.
    //所以一共n+1个数.最后dp[n][n]是因为之前重新调整数组时,n++,使得现在的n其实是n+2.
    //最后返回dp[0][n-1];也就是中间的题中所有的气球都戳破的情况,剩下的边界其实就是两个后来填进去填进去的值nums[-1]和nums[n].
    //确实这里是从下往上.

    //这里是新的解释.
//    在我们看到技巧之后，自上而下的方法非常简单：
//
//    用1填充数组的开头+结尾，因为问题以这种方式定义它，它不会影响最终值，最重要的是它消除了处理这些特殊情况的需要
//    意识到向后工作将允许我们将数组干净地划分为子问题（“反向思维”，如上文所述的dietpepsi）
//    首先弹出所有0个气球并从阵列中删除它们（因为它们没什么价值）
//    我们的主要等式中有3个变量：3个气球的弹出值。同样，我们使用我们刚刚填充数组的两个1来消除其中两个变量
//    现在只需尝试弹出所有可能的中间气球（第3个变量）。对于我们选择的每个气球，使用它作为下一级递归的左右气球，以及填充的1，等等。
//    基本情况是左右气球索引之间没有气球（左+ 1 ==右）
//    尽管如此，迭代方法是非常棘手的，但是如果我们从基本情况考虑那么容易：
//
//    自下而上的方法总是从基础案例开始并向上构建
//    基本情况是：当左+ 1 ==右，然后返回0. A.k.a.弹出中间没有气球。所以这些基本案例值已存储在我们的DP阵列中！
//    接下来的情况是我们左右之间只有一个气球。 k表示左右之间的距离，k = 2表示左右之间有一个气球
//    所以首先我们遍历整个数组，并在左右之间只有一个气球时找到每个结果，当它完成时，增加左右之间的距离k
//    请注意，dp行将dp [left] [right]分配给nums [left] * nums [i] * nums [right] + dp [left] [i] + dp [i] [right]）
//    dp [left] [i]和dp [i] [right]）当k = 2时等于基本情况！等于0！我们总是引用先前迭代的值。
//    继续增加左右之间的气球数量，直到我们到达最后的情况left = 0和right = n-1

    class Solution {
        public int maxCoins(int[] nums) {
            int[] nnums = new int[nums.length + 2];  //新的数组.加了两个边界
            int n = 1;  //索引
            for (int num : nums) {  //这边不需要判断num>0吧,无影响?
                nnums[n++] = num;
            }
            nnums[0] = nnums[n++] = 1;  //最前和最后置1.
            int[][] dp = new int[n][n];  //此时的n已经是比原来多2啦.
            for (int k = 2; k < n; k++) {
                for (int left = 0; left < n - k; left++) {
                    int right = left + k;
                    for (int i = left + 1; i < right; i++) {
                        dp[left][right] = Math.max(dp[left][right], nnums[left] * nnums[i] * nnums[right] + dp[left][i] + dp[i][right]);
                    }
                }

            }
            return dp[0][n - 1];
        }

    }
}
