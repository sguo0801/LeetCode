package Top100;

public class _11 {
    //AKA，找到一些最大值的一般想法是经历可能发生最大值的所有情况并继续更新最大值。扫描效率取决于您计划扫描的案例的大小。
    //为了提高效率，我们需要做的就是找到一种智能的扫描方式来切断无用的情况，同时100％保证在其他情况下可以达到最大值。
    //在这个问题中，智能扫描方式是设置在数组两端初始化的两个指针。每次将较小的值指针移动到内部数组。
    // 然后在两个指针相遇之后，扫描所有可能的最大情况，并且在扫描的某处达到最大情况100％。以下是对此的简要证明。
    //给定a1，a2，a3 .....作为输入数组。让我们假设a10和a20是最大面积情况。我们需要证明左指针可以达到a10，
    // 并且在指针停留在a10的时间内，右指针可以达到a20。也就是说，核心问题是要证明：当左指针位于a10且右指针位于a21时，下一步必须是指向a20的右指针。
    //因为我们总是用较小的值移动指针，即如果a10> a21，我们应该将指针移动到a21到a20，正如我们所希望的那样。
    // 为什么a10> a21？因为如果a21> a10，那么a10和a20的面积必须小于a10和a21的面积。因为a10和a21的面积至少是高度[a10] *（21-10），
    // 而a10和a20的面积是至多高度[a10] *（20-10）。因此假设a10和a20具有最大面积存在矛盾。所以，a10必须大于a21，然后下一步a21必须移动到a20。必须达到最大的情况。
//双指针,从两侧向中间靠拢,并更新容量.
    public int maxArea(int[] height) {
        int left = 0, right = height.length - 1;
        int maxArea = 0;

        while (left < right) {
            maxArea = Math.max(maxArea, Math.min(height[left], height[right])
                    * (right - left));
            if (height[left] < height[right])
                left++;
            else
                right--;
        }

        return maxArea;
    }
}
